<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>이미지 콜라주 생성기</title>
  <!-- Bootstrap & jQuery CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <style>
    :root {
      --dz-border: 2px dashed #9aa0a6;
      --dz-hover: #e8f0fe;
    }
    body { background: #f8f9fa; }
    .dropzone {
      border: var(--dz-border);
      background: #fff;
      border-radius: .75rem;
      padding: 2rem;
      text-align: center;
      color: #5f6368;
      transition: background-color .2s, border-color .2s;
      cursor: pointer;
    }
    .dropzone.dragover {
      background: var(--dz-hover);
      border-color: #1a73e8;
      color: #174ea6;
    }
    canvas {
      width: 100%;
      height: auto;
      background: #fff; /* JPG 내보낼 때 깔끔하도록 기본 흰 배경 */
      border-radius: .5rem;
      box-shadow: 0 2px 12px rgba(0,0,0,.06);
    }
    .control-label small { color:#6c757d; }
    .value-badge {
      font-variant-numeric: tabular-nums;
      min-width: 3ch;
      display:inline-block;
      text-align:right;
    }
    .sticky-actions {
      position: sticky;
      bottom: 0;
      background: rgba(248,249,250,.85);
      backdrop-filter: blur(6px);
      border-top: 1px solid rgba(0,0,0,.05);
      padding: .75rem;
      border-radius: 0 0 .75rem .75rem;
    }
    .small-note { font-size: .9rem; color:#6c757d; }
    .ratio-select { min-width: 140px; }
  </style>
</head>
<body>
  <div class="container py-4">
    <div class="row g-3">
      <div class="col-12">
        <h1 class="h3 mb-0">이미지 콜라주 생성기</h1>
        <p class="text-muted mb-2">여러 장의 사진을 드래그&드롭해서 자동 콜라주를 만들고, 설정을 바꿔가며 PNG/JPG로 저장하세요.</p>
      </div>

      <!-- 좌측: 컨트롤 + 드롭존 -->
      <div class="col-lg-4">
        <div class="card shadow-sm">
          <div class="card-body">
            <div id="dropZone" class="dropzone mb-3">
              <div class="d-flex flex-column align-items-center">
                <div class="mb-2">
                  <svg width="36" height="36" viewBox="0 0 24 24" fill="none">
                    <path d="M12 16V4m0 0l-4 4m4-4l4 4M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2"
                          stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </div>
                <div class="fw-semibold">이미지를 여기에 드롭</div>
                <div class="small text-muted">또는 아래 버튼으로 선택</div>
                <input type="file" id="fileInput" class="form-control mt-3" multiple accept="image/*">
              </div>
            </div>

            <div class="mb-2 small">
              불러온 이미지 수: <span id="imgCount" class="fw-semibold">0</span>장
            </div>

            <hr>

            <div class="mb-3">
              <label class="form-label control-label">Col (열)
                <small class="ms-2">1–20</small>
              </label>
              <div class="d-flex align-items-center gap-2">
                <input type="range" id="cols" class="form-range" min="1" max="20" step="1" value="3">
                <span class="badge bg-secondary"><span id="colsVal" class="value-badge">3</span></span>
              </div>
            </div>

            <div class="mb-3">
              <label class="form-label control-label">Row (행)
                <small class="ms-2">1–20</small>
              </label>
              <div class="d-flex align-items-center gap-2">
                <input type="range" id="rows" class="form-range" min="1" max="20" step="1" value="3">
                <span class="badge bg-secondary"><span id="rowsVal" class="value-badge">3</span></span>
              </div>
            </div>

            <div class="mb-3">
              <label class="form-label control-label">가로세로 비율</label>
              <select id="ratio" class="form-select ratio-select">
                <option value="1:1" selected>1 : 1</option>
                <option value="3:2">3 : 2</option>
                <option value="2:3">2 : 3</option>
                <option value="4:3">4 : 3</option>
                <option value="3:4">3 : 4</option>
                <option value="16:9">16 : 9</option>
                <option value="9:16">9 : 16</option>
              </select>
              <div class="form-text">출력 캔버스의 가로:세로 비율입니다.</div>
            </div>

            <!-- ★ 추가: Gutter 슬라이더 -->
            <div class="mb-3">
              <label class="form-label control-label">Gutter (칸 사이 간격, px)
                <small class="ms-2">0–200</small>
              </label>
              <div class="d-flex align-items-center gap-2">
                <input type="range" id="gutter" class="form-range" min="0" max="200" step="1" value="8">
                <span class="badge bg-secondary"><span id="gutterVal" class="value-badge">8</span> px</span>
              </div>
              <div class="small-note">과도한 값은 출력 크기에 맞춰 자동으로 줄여 안전하게 적용됩니다.</div>
            </div>

            <div class="mb-3">
              <label class="form-label control-label">전체 크기(가로 해상도, px)
                <small class="ms-2">512–8192</small>
              </label>
              <div class="d-flex align-items-center gap-2">
                <input type="range" id="widthPx" class="form-range" min="512" max="8192" step="128" value="2048">
                <span class="badge bg-secondary"><span id="widthVal" class="value-badge">2048</span> px</span>
              </div>
              <div class="small-note">세로 길이는 비율에 맞춰 자동 계산됩니다.</div>
              <div class="small mt-1">예상 출력 크기: <span id="whPreview" class="fw-semibold">2048 x 2048</span> px</div>
            </div>

            <div class="d-flex gap-2">
              <button id="shuffleBtn" type="button" class="btn btn-outline-primary flex-fill">Shuffle</button>
              <button id="clearBtn" type="button" class="btn btn-outline-secondary">Clear</button>
            </div>
          </div>

          <div class="sticky-actions">
            <div class="d-grid gap-2">
              <button id="dlPng" class="btn btn-success">Download PNG</button>
              <button id="dlJpg80" class="btn btn-outline-success">Download JPG (품질 80)</button>
              <button id="dlJpg100" class="btn btn-outline-success">Download JPG (품질 100)</button>
            </div>
            <div class="small-note mt-2">
              많은 이미지+초고해상도(>6000px)는 브라우저 메모리를 많이 사용합니다.
            </div>
          </div>
        </div>
      </div>

      <!-- 우측: 미리보기 캔버스 -->
      <div class="col-lg-8">
        <div class="card shadow-sm">
          <div class="card-body">
            <div class="d-flex justify-content-between align-items-center mb-2">
              <div class="fw-semibold">미리보기</div>
              <div class="small text-muted">중복 없이 배치되며, 남는 셀은 비워둡니다. 셀 비율에 맞춰 중앙 크롭됩니다.</div>
            </div>
            <canvas id="previewCanvas" width="2048" height="2048" aria-label="콜라주 미리보기"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 전역 상태
    const state = {
      images: [],  // {img: HTMLImageElement, name: string, w: number, h: number}
      cols: 3,
      rows: 3,
      widthPx: 2048,
      ratio: {w:1, h:1},
      gutterPx: 8, // ★ 추가: 셀 간격(px)
    };

    const $cols = $('#cols');
    const $rows = $('#rows');
    const $widthPx = $('#widthPx');
    const $ratio = $('#ratio');
    const $gutter = $('#gutter');
    const $imgCount = $('#imgCount');
    const $whPreview = $('#whPreview');
    const $dropZone = $('#dropZone');
    const $fileInput = $('#fileInput');
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');

    function parseRatio(val) {
      // "3:2" 또는 "3x2" 모두 허용
      const clean = val.replace('x', ':');
      const [w, h] = clean.split(':').map(n => Math.max(1, parseInt(n, 10)));
      return { w, h };
    }

    function updateFromControls() {
      state.cols = parseInt($cols.val(), 10);
      state.rows = parseInt($rows.val(), 10);
      state.widthPx = parseInt($widthPx.val(), 10);
      state.ratio = parseRatio($ratio.val());
      state.gutterPx = parseInt($gutter.val(), 10);

      $('#colsVal').text(state.cols);
      $('#rowsVal').text(state.rows);
      $('#widthVal').text(state.widthPx);
      $('#gutterVal').text(state.gutterPx);

      const outH = Math.round(state.widthPx * state.ratio.h / state.ratio.w);
      $whPreview.text(`${state.widthPx} x ${outH}`);
      scheduleRender();
    }

    // 드롭 & 파일 선택
    function handleFiles(fileList) {
      const files = Array.from(fileList).filter(f => f.type.startsWith('image/'));
      if (!files.length) return;

      files.forEach(file => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          state.images.push({ img, name: file.name || 'image', w: img.naturalWidth, h: img.naturalHeight });
          URL.revokeObjectURL(url);
          $imgCount.text(state.images.length);
          scheduleRender();
        };
        img.onerror = () => {
          URL.revokeObjectURL(url);
        };
        img.src = url;
      });
    }

    // 드래그 이벤트 방지 및 처리
    ['dragenter','dragover','dragleave','drop'].forEach(ev => {
      document.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); }, false);
    });

    $dropZone.on('dragenter dragover', () => $dropZone.addClass('dragover'));
    $dropZone.on('dragleave', () => $dropZone.removeClass('dragover'));
    $dropZone.on('drop', e => {
      $dropZone.removeClass('dragover');
      const dt = e.originalEvent.dataTransfer;
      handleFiles(dt.files);
    });

    $fileInput.on('change', e => handleFiles(e.target.files));

    // 셔플
    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i++) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
    $('#shuffleBtn').on('click', () => {
      if (state.images.length > 1) {
        shuffleInPlace(state.images);
        scheduleRender();
      }
    });

    // 클리어
    $('#clearBtn').on('click', () => {
      state.images = [];
      $imgCount.text('0');
      scheduleRender();
    });

    // 다운로드
    function download(type, quality) {
      const outW = state.widthPx;
      const outH = Math.round(state.widthPx * state.ratio.h / state.ratio.w);
      const ratioStr = `${state.ratio.w}x${state.ratio.h}`;
      const base = `collage_${outW}x${outH}_${state.cols}x${state.rows}_${ratioStr}_g${state.gutterPx}`;
      const ext = type === 'image/png' ? 'png' : 'jpg';
      const qSuffix = (type === 'image/jpeg' && typeof quality === 'number') ? `_q${Math.round(quality*100)}` : '';
      const filename = `${base}${qSuffix}.${ext}`;

      const url = canvas.toDataURL(type, quality);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    $('#dlPng').on('click', () => download('image/png'));
    $('#dlJpg80').on('click', () => download('image/jpeg', 0.80));
    $('#dlJpg100').on('click', () => download('image/jpeg', 1.00));

    // 렌더링 스케줄
    let renderPending = false;
    function scheduleRender() {
      if (renderPending) return;
      renderPending = true;
      requestAnimationFrame(() => {
        drawCollage();
        renderPending = false;
      });
    }

    function drawCollage() {
      const cols = Math.max(1, state.cols);
      const rows = Math.max(1, state.rows);
      const outW = Math.max(1, state.widthPx);
      const outH = Math.round(outW * state.ratio.h / state.ratio.w);

      // 캔버스
      canvas.width = outW;
      canvas.height = outH;

      // 배경 흰색
      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, outW, outH);
      ctx.restore();

      if (state.images.length === 0) {
        ctx.save();
        ctx.fillStyle = '#9aa0a6';
        ctx.font = `${Math.max(16, Math.floor(outW * 0.02))}px system-ui, -apple-system, 'Segoe UI', Roboto, Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('여기에 이미지를 드롭하거나 "파일 선택"으로 추가하세요', outW/2, outH/2);
        ctx.restore();
        return;
      }

      // ── Gutter(내부 간격만, 외곽 여백 없음) ─────────────────────────────
      const wanted = Math.max(0, state.gutterPx);

      // 각 축에서 셀 높이/너비가 1px 이상 되도록 허용 가능한 최대 gutter (정수화)
      const maxGX = (cols > 1) ? Math.floor((outW - cols) / (cols - 1)) : 0;
      const maxGY = (rows > 1) ? Math.floor((outH - rows) / (rows - 1)) : 0;

      let gX = 0, gY = 0;
      if (cols > 1 && rows > 1) {
        const g = Math.floor(Math.min(wanted, maxGX, maxGY)); // 두 축 동일값으로 잠금
        gX = g; gY = g;
      } else if (cols > 1) {
        gX = Math.floor(Math.min(wanted, maxGX));
      } else if (rows > 1) {
        gY = Math.floor(Math.min(wanted, maxGY));
      }

      // 부동소수 셀 크기(이 값으로 누적해서 경계 생성 → 정수 경계 배열)
      const cellWf = (outW - (cols - 1) * gX) / cols;
      const cellHf = (outH - (rows - 1) * gY) / rows;

      // ── 핵심: 정수 경계 배열을 먼저 만든 뒤 그리기 ───────────────────────
      const xEdges = new Array(cols + 1);
      const yEdges = new Array(rows + 1);

      // 열 경계
      xEdges[0] = 0;
      let accX = 0;
      for (let c = 0; c < cols; c++) {
        accX += cellWf;                          // 셀 너비 누적
        xEdges[c + 1] = Math.round(accX + c * gX); // (c개 간격) 더한 위치를 반올림
      }
      xEdges[cols] = outW; // 마지막은 확실히 맞춤

      // 행 경계
      yEdges[0] = 0;
      let accY = 0;
      for (let r = 0; r < rows; r++) {
        accY += cellHf;
        yEdges[r + 1] = Math.round(accY + r * gY);
      }
      yEdges[rows] = outH;

      const totalCells = cols * rows;
      const useCount = Math.min(totalCells, state.images.length); // 중복 금지

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      for (let i = 0; i < useCount; i++) {
        const r = Math.floor(i / cols);
        const c = i % cols;

        const rx = xEdges[c];
        const ry = yEdges[r];
        const rw = xEdges[c + 1] - xEdges[c] - (c < cols - 1 ? gX : 0); // 내부 간격 제거
        const rh = yEdges[r + 1] - yEdges[r] - (r < rows - 1 ? gY : 0);

        const x = rx + (c > 0 ? gX * c : 0); // 실제 셀 x 시작점
        const y = ry + (r > 0 ? gY * r : 0); // 실제 셀 y 시작점

        const { img, w, h } = state.images[i];

        // 셀 경계로 클리핑(틈/넘침 방지)
        ctx.save();
        ctx.beginPath();
        ctx.rect(x, y, rw, rh);
        ctx.clip();

        // cover(중앙 크롭)
        const scale = Math.max(rw / w, rh / h);
        const dw = w * scale;
        const dh = h * scale;
        const dx = x + (rw - dw) / 2;
        const dy = y + (rh - dh) / 2;

        ctx.drawImage(img, dx, dy, dw, dh);
        ctx.restore();
      }
      // 남는 칸은 흰 배경으로 비워둡니다.
    }

    // 컨트롤 이벤트
    $cols.on('input change', updateFromControls);
    $rows.on('input change', updateFromControls);
    $widthPx.on('input change', updateFromControls);
    $ratio.on('change', updateFromControls);
    $gutter.on('input change', updateFromControls);

    // 초기 표시
    updateFromControls();
  </script>
</body>
</html>
